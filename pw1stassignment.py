# -*- coding: utf-8 -*-
"""PW1stassignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BEveVL000VlmyAnO644f_OH9-Nre8qZ7
"""

18 July Assignment

Section 1 : Python Basics Questions

Q1. What is Python, and why is it popular?

Ans.

Python is a high-level, interpreted programming language known for its simplicity and readability. It was created by Guido van Rossum and first released in 1991.

Python is widely used for various purposes, including web development, data analysis, artificial intelligence, machine learning, automation, and more.

Reasons for Python’s popularity:

Easy to Learn: Its clean and readable syntax makes it ideal for beginners.
Versatile: Applicable in many domains such as web development, data science, AI, scripting, and automation.
Large Community: A vast number of libraries, frameworks, tutorials, and community support are available.
Cross-Platform: Python code can run on different operating systems without modification.
High Demand: Its widespread use in the tech industry leads to strong job opportunities.

Q2. What is an interpreter in Python?

Ans.

An interpreter in Python is a program that executes code line by line, translating high-level Python instructions into machine-level code at runtime. Unlike compiled languages, Python does not require a separate compilation step—the interpreter processes the code directly and immediately.

This approach offers several advantages:

Interactive Development: You can test code snippets in real-time using tools like the Python shell or Jupyter Notebook.
Faster Debugging: Errors can be detected and fixed quickly, as the code runs line by line.
Platform Independence: The interpreter abstracts away platform-specific details, making Python programs portable across systems.
python’s interpreted nature is one of the key reasons it is so popular for rapid development, scripting, and learning programming.

Q3. What are pre-defined keywords in Python?

Ans.

Pre-defined keywords in Python are reserved words that are an integral part of the language's syntax and structure. These keywords convey specific meanings and instructions to the Python interpreter and cannot be used as identifiers, such as variable names, function names, or class names.

They are used to define the logic, control flow, and structure of Python programs.

Examples of Python keywords include:

Control flow: if, elif, else, while, for, break, continue, pass
Function and class definitions: def, return, lambda, class
Exception handling: try, except, finally, raise
Module management: import, from, as
Boolean and null values: True, False, None
Other structural elements: with, yield, global, nonlocal, assert, del, is, in, not, and, or
To view the full list of keywords in your Python environment, you can use the following code:

help('keywords')
Note: As of Python 3.x, there are over 30 keywords. Python keywords are case-sensitive and always written in lowercase (except True, False, and None).

# use below also to see all keyword in one screen
help('keywords')
Here is a list of the Python keywords.  Enter any keyword to get more help.

False               class               from                or
None                continue            global              pass
True                def                 if                  raise
and                 del                 import              return
as                  elif                in                  try
assert              else                is                  while
async               except              lambda              with
await               finally             nonlocal            yield
break               for                 not

Q4. Can keywords be used as variable names?

Ans.

No, keywords cannot be used as variable names in Python. Keywords are reserved words that have predefined meanings and are used to define the syntax and structure of the language. Using them as variable names will result in a SyntaxError.

🔒 Why not?

Each keyword has a specific role (e.g., if for conditions, def for functions). Allowing them as variable names would create ambiguity in the code and confuse the interpreter.

❌ Invalid Examples (will cause errors):

if = 10 #SyntaxError
def = "func" #SyntaxError
class = "A" #SyntaxError
✅ Valid Alternatives:

if_condition = 10
def_name = "func"
class_name = "A"
✅ How to check if a word is a keyword:

import keyword
print(keyword.iskeyword("if")) #Output will be True
print(keyword.iskeyword("username")) #Output will be False
if = 10       #SyntaxError
def = "func"  #SyntaxError
class = "A"   #SyntaxError
  Cell In[12], line 1
    if = 10       #SyntaxError
       ^
SyntaxError: invalid syntax
if_condition = 10
def_name = "func"
class_name = "A"
import keyword
print(keyword.iskeyword("if"))         #Output will be True
print(keyword.iskeyword("username"))   #Output will be False
True
False

Q5. What is mutability in Python?

Ans.

Mutability refers to whether an object’s content can be changed after it is created.
Mutable objects can be modified in place. Examples: lists, dictionaries, sets. are mutable
Immutable objects cannot be changed once created—any modification creates a new object.
🔁 Mutable Objects : These objects can be changed without changing their identity (memory address).

🔁 Why it matters: : Understanding mutability is crucial for writing efficient code, especially when dealing with function arguments, memory usage, and debugging side effects.

# Examples for mutable
# Mutable example (list)
my_list = [1, 2, 3]
my_list[0] = 10  # Modifying the list
print(my_list)  # Output: [10, 2, 3]

# Immutable example (string)
my_string = "hello"
# This will create a new string instead of modifying the original one
my_string = "world"  # Reassigning to a new string
print(my_string)  # Output: world
[10, 2, 3]
world

Q6. Why are lists mutable, but tuples are immutable?

Ans.

Lists are mutable, while tuples are immutable, due to the design choices in Python to provide different behaviors for these data structures.

🔁 Lists – Mutable Data Structures

Lists are mutable, meaning their contents can be altered after creation. This includes operations such as:

Modifying elements
Adding or removing items
Reordering elements
This flexibility makes lists suitable for dynamic datasets where modification is expected during the program’s execution.

Example:

#example of Mutable using list
my_list = [1, 2, 3]
my_list[0] = 10       # Modifies the first element
my_list.append(4)     # Adds a new element
🔒 Tuples – Immutable Data Structures

Tuples, on the other hand, are immutable. Once a tuple is created, its contents cannot be changed. Any attempt to modify an element will result in a TypeError.

This immutability provides several advantages:

Data Integrity: Prevents accidental changes, which is critical in situations requiring constant data.
Hashability: Tuples can be used as keys in dictionaries and elements in sets—something mutable objects like lists cannot do.
Performance: Tuples are generally more memory-efficient and slightly faster due to their fixed size and structure.
Example:

my_tuple = (1, 2, 3)
my_tuple[0] = 10  # ❌ TypeError: 'tuple' object does not support item assignment
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[21], line 2
      1 my_tuple = (1, 2, 3)
----> 2 my_tuple[0] = 10  # ❌ TypeError: 'tuple' object does not support item assignment

TypeError: 'tuple' object does not support item assignment
Summary:

Feature List (Mutable)  Tuple (Immutable)
Modifiable  Yes No
Syntax  [1, 2, 3]   (1, 2, 3)
Use Case    Dynamic data    Fixed/constant data
Memory Efficiency   Less efficient  More efficient
Hashable (usable as dict key)   No  Yes (if fully immutable)
Conclusion:

The mutability of lists allows for flexible, dynamic data management, whereas the immutability of tuples ensures data stability, hashability, and optimization in contexts where change is neither expected nor desired.

Q7. What is the difference between “==” and “is” operators in Python?

Ans.

In Python, == and is are comparison operators, but they serve different purposes:

🔹 == (Equality Operator)

Compares the values of two objects.

Returns True if the contents are equal, even if the objects are stored at different memory locations.

Example:

a = [1, 2, 3]
b = [1, 2, 3]
print(a == b) # ✅ True — values are the same
🔹 is (Identity Operator)

Compares the identity of two objects (i.e., whether they refer to the same memory location).
Returns True only if both variables point to the exact same object.
Example:

a = [1, 2, 3]
b = [1, 2, 3]
c = a
print(a is b) # ❌ False — different objects in memory
print(a is c) # ✅ True — same object
Note: For immutable types like small integers and strings, Python may optimize memory usage by reusing objects, which can make is appear True in some cases—but this behavior should not be relied upon for equality checks.

est Practice:

Use == for comparing values and is for checking object identity or comparing to None (e.g., if x is None:).
Test given example here:

# (==) Equality Operator
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)  # ✅ True — values are the same
True
# is Operator
a = [1, 2, 3]
b = [1, 2, 3]
c = a
print(a is b)  # ❌ False — different objects in memory
print(a is c)  # ✅ True — same object
False
True

Q8. What are logical operators in Python?

Ans.

Logical operators in Python are used to combine conditional statements and return a Boolean result (True or False). They operate on Boolean values and are primarily used in control flow (e.g., if, while) and expressions involving conditions.

Python provides three logical operators:

and (Logical AND)

Returns True if both conditions are True.
Returns False if any condition is False.
or (Logical OR)

Returns True if at least one condition is True.
Returns False only if both conditions are False.
not (Logical NOT)

Reverses the Boolean value.
not True becomes False, and not False becomes True.
Summary:

Operator    Description Example Result
and True if both are True   True and False  False
or  True if at least one is True    False or True   True
not Inverts the result  not True    False
# and Example
x = 5
print(x > 2 and x < 10)  # ✅ True
True
# or Example
x = 5
print(x < 3 or x > 2)  # ✅ True
True
# not Example
x = False
print(not x)  # ✅ True
True

Q9. What is type casting in Python?

Ans.

Type casting in Python refers to the process of converting a value from one data type to another. It is used to ensure compatibility between different types in expressions or functions, especially when combining strings, numbers, or collections.

There can be two types of Type Casting in Python:

Python Implicit Type Conversion
Python Explicit Type Conversion

Q10. What is the difference between implicit and explicit type casting?

Ans.

Implicit Type Casting:

Performed automatically by Python when it safely converts one data type to another without data
Occurs when combining different numeric types (int, float) in expressions.
Python handles the conversion internally without programmer intervention.
Explicit Type Castinh.

Done manually by the programmer using built-in functions to force a type conversion.
Used when Python does not automatically convert types (e.g., string to integer).
Helps prevent errors in operations requiring matching types.
Summary

Feature Implicit Casting    Explicit Casting
Performed By    Python interpreter  Programmer
Conversion Type Automatic and safe conversions  Manual conversions (may lose data)
Use Case    Numeric operations  Mixed-type operations (e.g., str to int)
Risk of Data Loss   Minimal Possible (e.g., float to int)
Syntax Example  int + float → float int("5"), float("3.14")
EXAMPLES GIVEN BELOW FOR CLEAR UNDERSTANDING

# Implicit Type Casting Example:
x = 10       # int
y = 3.5      # float

result = x + y  # int is implicitly converted to float
print(result)   # Output: 13.5
print(type(result))  # <class 'float'>
13.5
<class 'float'>
# Explicit Type casting Example:
a = "100"        # str
b = int(a)       # Explicit cast to int

c = 3.99
d = int(c)       # Explicit cast to int (truncates decimal)

print(b + d)     # Output: 103
103

Q11. What is the purpose of conditional statements in Python?

Ans.

Conditional statements in Python are used to control the flow of execution based on specified conditions. They allow programs to make decisions, execute certain blocks of code only when a condition is met, and handle different scenarios dynamically.

🎯 Primary Purpose:

To enable decision-making in a program by executing different code paths depending on whether a given condition evaluates to True or False.

Common Conditional Statements in Python:

if statement – Executes a block if the condition is True.
if-else statement – Executes one block if the condition is True, another if it is False.
if-elif-else chain – Checks multiple conditions in sequence.
Why Conditional Statements Are Important:

Introduce logic and intelligence into programs
Allow programs to respond to input or data
Make programs interactive and dynamic
Essential for implementing loops, functions, and algorithms
Conclusion::
Conditional statements are fundamental to programming logic. They enable Python programs to behave differently under varying conditions, making the software functional, flexible, and intelligent.

# if example
age = 25
if age >= 18:
    print("You are eligible to vote.")
You are eligible to vote.

# if-elseexample:
num = 5
if num % 2 == 0:
    print("Even")
else:
    print("Odd")
Odd
#if-elif-else example:
score = 85
if score >= 90:
    print("Grade: A")
elif score >= 80:
    print("Grade: B")
else:
    print("Grade: C or below")
Grade: B

Q12. How does the elif statement work?

Ans.

The elif (short for “else if”) statement in Python is used to check multiple conditions sequentially. It allows a program to test several expressions for truth value and execute a specific block of code for the first true condition encountered.

Synax:

if condition1: # Do this if condition1 is True elif condition2: # Do this if condition1 is False AND condition2 is True elif condition3: # Do this if previous conditions are False AND condition3 is True else: # Do this if none of the above conditions are True

How it works:

The program evaluates each condition in order.
As soon as it finds a condition that is True, it executes that block and skips the rest.
If none of the if or elif conditions are true, it executes the else block (if provided).
🔒 Important Notes:

elif is only evaluated if all previous if/elif conditions are False.
You can have multiple elif statements, but only one else (which is optional).
Improves readability compared to nested if statements.
#Example
score = 75

if score >= 90:
    print("Grade: A")
elif score >= 80:
    print("Grade: B")
elif score >= 70:
    print("Grade: C")
else:
    print("Grade: D or F")
Grade: C

Q13. What is the difference between for and while loops?

Ans.

In Python, both for and while loops are used for iteration,but they differ in usage, structure, and control logic.

for loop:

The for loop is used for iterating over a sequence (like a list, tuple, string, or range).
It is typically used when the number of iterations is known or predetermined.
Use case: The for loop is used when the number of iterations is known or when iterating over a collection.
Synax:

for item in sequence: # code block

while loop:

The while loop runs as long as a condition is true.
It is typically used when the number of iterations is unknown and depends on a condition.
Use case: The while loop is used when you do not know the number of iterations in advance but want to repeat until a certain condition is met
Synax:

while condition: # code block

Summary of Differences:

Feature for Loop    while Loop
Iteration Type  Definite    Indefinite
Use Case    When iterating over a sequence  When looping until a condition is false
Loop Control    Controlled by iterable (e.g., range)    Controlled by condition
Risk of Infinite Loop   Low Higher (if condition never becomes False)
Common Uses Iterating lists, ranges, strings    Waiting for user input, retry logic
# Iterating through a list using a for loop
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)
apple
banana
cherry
# Using a while loop to print numbers from 1 to 5
x = 1
while x <= 5:
    print(x)
    x += 1
1
2
3
4
5

Q14. Describe a scenario where a while loop is more suitable than a for loop?

Ans.

A while loop is more suitable than a for loop in situations where the number of iterations is unknown and depends on a dynamic condition that can change during the loop execution.

Scenario:

User Input Validation
Consider a scenario where you want to ask the user for their age.
The user should only enter a valid age (a positive integer).
If the user enters an invalid age (such as a negative number or a non-numeric input), the program should keep asking until a valid input is given.
Since you don't know how many attempts it will take for the user to provide valid input, a while loop is more suitable here.
Why while is suitable:

The number of attempts is unknown.
The loop continues until the condition (a valid age) is met, making it ideal for input validation.
# EXAMPLE CASE FOR NDERTANDING
number = -1

while number <= 0:
    try:
        number = int(input("Enter a positive number: "))
    except ValueError:
        print("Invalid input. Please enter a number.")

print(f"You entered: {number}")
You entered: 1

Section 2 : Python Practical Questions

Q1. Write a Python program to print "Hello, World!"

#Write a Python Program to print hello World
#Ans:
print("Hello, World!")
Hello, World!

Q2. Write a Python program that displays your name and age.

#Write a Python program that displays your name and age.
#Ans_1:
name = "Aman Bishnoi"
age = 25
print("Hi my name is: ", name, age)
Hi my name is: Aman Bishnoi 25
#Ans_2:
name = "Aman Bishnoi"
age = 25
print(f"My name is {name} and I am {age} years old.")
My name is Aman Bishnoi and I am 25 years old.

Q3. Write code to print all the pre-defined keywords in Python using the keyword library?

# Write code to print all the pre-defined keywords in Python using the keyword library
#Ans_1:
help('keywords')
Here is a list of the Python keywords.  Enter any keyword to get more help.

False               class               from                or
None                continue            global              pass
True                def                 if                  raise
and                 del                 import              return
as                  elif                in                  try
assert              else                is                  while
async               except              lambda              with
await               finally             nonlocal            yield
break               for                 not

#Ans_2: keyword in list
import keyword
print(keyword.kwlist)
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

Q4. Write a program that checks if a given word is a Python keyword?

#Ans.
import keyword
# Prompt the user for input
word = input("Enter a word to check if it's a Python keyword: ")

# Check and display result
if keyword.iskeyword(word):
    print(f"✅ '{word}' is a Python keyword.")
else:
    print(f"❌ '{word}' is NOT a Python keyword.")
Notes:

The keyword module is part of the Python standard library.
keyword.iskeyword(word) returns True if the word is a reserved Python keyword (e.g., def, if, return), otherwise False.

Q5. Create a list and tuple in Python, and demonstrate how attempting to change an element works differently for each.

#Ans.
# Define a list (mutable)
my_list = [10, 20, 30]
print("Original list:", my_list)

# Modify an element inthe list
my_list[1] = 99
print("Modified list:", my_list)

# Define a tuple (immutable)
my_tuple = (10, 20, 30)
print("\nOriginal tuple:", my_tuple)

# Attempt to modify an element in the tuple
try:
    my_tuple[1] = 99
except TypeError as e:
    print("Error when modifying tuple:", e)
Original list: [10, 20, 30]
Modified list: [10, 99, 30]

Original tuple: (10, 20, 30)
Error when modifying tuple: 'tuple' object does not support item assignment
6. Write a function to demonstrate the behavior of mutable and immutable arguments.

#Ans:
def modify_data(num, data_list):
    # Try modifying the immutable integer
    num += 10
    print(f"Inside function - num (immutable): {num}")

    # Modify the mutable list
    data_list.append(100)
    print(f"Inside function - data_list (mutable): {data_list}")

# Immutable object (int)
x = 5
# Mutable object (list)
my_list = [1, 2, 3]

print("Before function call:")
print(f"x: {x}")
print(f"my_list: {my_list}")

# Call the function
modify_data(x, my_list)

print("\nAfter function call:")
print(f"x (unchanged): {x}")
print(f"my_list (modified): {my_list}")
Before function call:
x: 5
my_list: [1, 2, 3]
Inside function - num (immutable): 15
Inside function - data_list (mutable): [1, 2, 3, 100]

After function call:
x (unchanged): 5
my_list (modified): [1, 2, 3, 100]
Explanation:

x (int) is an immutable object. Even though it was changed inside the function, the change did not affect the original variable outside the function.
my_list (list) is a mutable object. Modifying it inside the function affects the original list.
Conclusion:

Immutable types (e.g., int, str) retain their original value outside the function.

Mutable types (e.g., list, dict) can be modified in-place within the function, and those changes persist.
Q7. Write a program that performs basic arithmetic operations on two user-input numbers.

Ans.
Take input from the user
num1 = float(input("Enter the first number: ")) num2 = float(input("Enter the second number: "))

Perform arithmetic operations
addition = num1 + num2 subtraction = num1 - num2 multiplication = num1 * num2

Handle division carefully to avoid division by zero
if num2 != 0: division = num1 / num2 modulus = num1 % num2 else: division = "Undefined (division by zero)" modulus = "Undefined (modulus by zero)"

Display results
print("\n--- Results ---") print(f"Addition: {addition}") print(f"Subtraction: {subtraction}") print(f"Multiplication: {multiplication}") print(f"Division: {division}") print(f"Modulus: {modulus}")

Q8. Write a program to demonstrate the use of logical operators.

Ans.

Logical Operator are:

Operator    Description Example
and True if both conditions are true    age >= 18 and has_ticket == 'yes'
or  True if at least one is true    age >= 18 or has_ticket == 'yes'
not Reverses the result (True ⇄ False)  not is_member == 'yes'
# Take input from the user
age = int(input("Enter your age: "))
has_ticket = input("Do you have a ticket? (yes/no): ").lower()

# Take input from the user
age = int(input("Enter your age: "))
has_ticket = input("Do you have a ticket? (yes/no): ").lower()

# Use logical AND
if age >= 18 and has_ticket == 'yes':
    print("Entry allowed.")
else:
    print("Entry denied.")

# Use logical OR
if age >= 18 or has_ticket == 'yes':
    print("You meet at least one requirement.")

# Use logical NOT
is_member = input("Are you a member? (yes/no): ").lower()
if not is_member == 'yes':
    print("Access to member area denied.")
else:
    print("Welcome to the member area.")
Entry allowed.
You meet at least one requirement.
Access to member area denied.
Q9. Write a Python program to convert user input from string to integer, float, and boolean types.

#Ans_1
# Take user input as a string
user_input = input("Enter a value: ")

# Convert to integer
try:
    int_value = int(user_input)
    print(f"Integer conversion successful: {int_value}")
except ValueError:
    print("Cannot convert to integer.")

# Convert to float
try:
    float_value = float(user_input)
    print(f"Float conversion successful: {float_value}")
except ValueError:
    print("Cannot convert to float.")

# Convert to boolean
# Any non-empty string except 'False' (case-insensitive) is considered True
bool_value = user_input.strip().lower() not in ['false', '0', '', 'none']
print(f"Boolean conversion result: {bool_value}")
Integer conversion successful: 5
Float conversion successful: 5.0
Boolean conversion result: True
#Ans_2:
# Get input from the user (input is always a string)
user_input = input("Enter a value: ")

# Convert to integer
int_value = int(user_input)  # Convert input to integer
print("Integer:", int_value)

# Convert to float
float_value = float(user_input)  # Convert input to float
print("Float:", float_value)

# Convert to boolean (empty string is False, non-empty string is True)
bool_value = bool(user_input)
print("Boolean:", bool_value)
Integer: 45
Float: 45.0
Boolean: True
Q10. Write code to demonstrate type casting with list elements

#Ans.
# Original list of string numbers
str_list = ['10', '20', '30', '0', '']

print("Original string list:", str_list)

# Convert to integers (ignoring invalid entries)
int_list = []
for item in str_list:
    try:
        int_list.append(int(item))
    except ValueError:
        int_list.append(None)  # or use a default value
print("Integer list:", int_list)

# Convert to floats
float_list = []
for item in str_list:
    try:
        float_list.append(float(item))
    except ValueError:
        float_list.append(None)
print("Float list:", float_list)

# Convert to booleans
bool_list = [bool(item) for item in str_list]
print("Boolean list:", bool_list)
Original string list: ['10', '20', '30', '0', '']
Integer list: [10, 20, 30, 0, None]
Float list: [10.0, 20.0, 30.0, 0.0, None]
Boolean list: [True, True, True, True, False]
Q11. Write a program that checks if a number is positive, negative, or zero

#Ans.
# Take input from the user
num = float(input("Enter a number: "))

# Check if the number is positive, negative, or zero
if num > 0:
    print("The number is positive.")
elif num < 0:
    print("The number is negative.")
else:
    print("The number is zero.")
The number is positive.
Q12. Write a for loop to print numbers from 1 to 10.

#Ans.
for i in range(1, 11):
    print(i)
1
2
3
4
5
6
7
8
9
10
Q13. Write a Python program to find the sum of all even numbers between 1 and 50.

#Ans.
# Initialize sum
even_sum = 0

# Loop through numbers 1 to 50
for number in range(1, 51):
    if number % 2 == 0:
        even_sum += number

# Display the result
print("The sum of all even numbers from 1 to 50 is:", even_sum)
The sum of all even numbers from 1 to 50 is: 650
Q14. Write a program to reverse a string using a while loop

#Ans.
# Take input from the user
original_string = input("Enter a string to reverse: ")

# Initialize an empty string for the reversed result
reversed_string = ""

# Set the index to the last character
index = len(original_string) - 1

# Loop through the string in reverse using a while loop
while index >= 0:
    reversed_string += original_string[index]
    index -= 1

# Display the reversed string
print("Reversed string:", reversed_string)
Reversed string: rizaN remU
Q15. Write a Python program to calculate the factorial of a number provided by the user using a while loop.

#Ans.
# Take input from the user
num = int(input("Enter a non-negative integer: "))

# Validate input
if num < 0:
    print("Factorial is not defined for negative numbers.")
else:
    factorial = 1
    counter = num

    while counter > 1:
        factorial *= counter
        counter -= 1

    # Display the result
    print(f"The factorial of {num} is: {factorial}")
The factorial of 5 is: 120